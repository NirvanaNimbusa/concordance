'use strict'

const flattenDeep = require('lodash.flattendeep')

// Increment if encoding layout, descriptor IDs, or value types change. Previous Kathryn versions will not be able to
// decode buffers generated by a newer version, so changing this value will require a major version bump of Kathryn
// itself. The version is encoded as an unsigned 8 bit integer. If it ever reaches 255 it *must* be encoded as a 16 bit
// integer instead.
const VERSION = 0

// Indexes are hexadecimal to make reading the binary output easier.
const valueTypes = {
  zero: 0x00,
  int8: 0x01,  // Note that the hex value equals the number of bytes required
  int16: 0x02, // to store the integer.
  int24: 0x03,
  int32: 0x04,
  int40: 0x05,
  int48: 0x06,
  numberString: 0x07,
  negativeZero: 0x08,
  notANumber: 0x09,
  infinity: 0x0A,
  negativeInfinity: 0x0B,
  undefined: 0x0C,
  null: 0x0D,
  true: 0x0E,
  false: 0x0F,
  utf8: 0x10,
  bytes: 0x11,
  list: 0x12,
  descriptor: 0x13
}

const descriptorSymbol = Symbol('descriptor')
exports.descriptorSymbol = descriptorSymbol

function encodeInteger (type, value) {
  const encoded = Buffer.alloc(type)
  encoded.writeIntLE(value, 0, type)
  return [type, encoded]
}

function encodeValue (value) {
  if (Object.is(value, 0)) return valueTypes.zero
  if (Object.is(value, -0)) return valueTypes.negativeZero
  if (Object.is(value, NaN)) return valueTypes.notANumber
  if (value === Infinity) return valueTypes.infinity
  if (value === -Infinity) return valueTypes.negativeInfinity
  if (value === undefined) return valueTypes.undefined
  if (value === null) return valueTypes.null
  if (value === true) return valueTypes.true
  if (value === false) return valueTypes.false

  const type = typeof value
  if (type === 'number') {
    if (Number.isInteger(value)) {
      // The integer types are signed, so int8 can only store 7 bits, int16
      // only 15, etc.
      if (value >= -0x80 && value < 0x80) return encodeInteger(valueTypes.int8, value)
      if (value >= -0x8000 && value < 0x8000) return encodeInteger(valueTypes.int16, value)
      if (value >= -0x800000 && value < 0x800000) return encodeInteger(valueTypes.int24, value)
      if (value >= -0x80000000 && value < 0x80000000) return encodeInteger(valueTypes.int32, value)
      if (value >= -0x8000000000 && value < 0x8000000000) return encodeInteger(valueTypes.int40, value)
      if (value >= -0x800000000000 && value < 0x800000000000) return encodeInteger(valueTypes.int48, value)
      // Fall through to encoding the value as a number string.
    }

    const encoded = Buffer.from(String(value), 'utf8')
    return [valueTypes.numberString, encodeValue(encoded.length), encoded]
  }

  if (type === 'string') {
    const encoded = Buffer.from(value, 'utf8')
    return [valueTypes.utf8, encodeValue(encoded.length), encoded]
  }

  if (Buffer.isBuffer(value)) {
    return [valueTypes.bytes, encodeValue(value.byteLength), value]
  }

  if (Array.isArray(value)) {
    return [
      value[descriptorSymbol] ? valueTypes.descriptor : valueTypes.list,
      encodeValue(value.length),
      value.map(encodeValue)
    ]
  }

  const hex = `0x${type.toString(16).toUpperCase()}`
  throw new TypeError(`Unexpected value with type ${hex}`)
}

function decodeValue (buffer, byteOffset) {
  const type = buffer.readUInt8(byteOffset)
  byteOffset += 1

  if (type === valueTypes.zero) return { byteOffset, value: 0 }
  if (type === valueTypes.negativeZero) return { byteOffset, value: -0 }
  if (type === valueTypes.notANumber) return { byteOffset, value: NaN }
  if (type === valueTypes.infinity) return { byteOffset, value: Infinity }
  if (type === valueTypes.negativeInfinity) return { byteOffset, value: -Infinity }
  if (type === valueTypes.undefined) return { byteOffset, value: undefined }
  if (type === valueTypes.null) return { byteOffset, value: null }
  if (type === valueTypes.true) return { byteOffset, value: true }
  if (type === valueTypes.false) return { byteOffset, value: false }

  if (
    type === valueTypes.int8 || type === valueTypes.int16 || type === valueTypes.int24 ||
    type === valueTypes.int32 || type === valueTypes.int40 || type === valueTypes.int48
  ) {
    const value = buffer.readIntLE(byteOffset, type)
    byteOffset += type
    return { byteOffset, value }
  }

  if (type === valueTypes.numberString || type === valueTypes.utf8 || type === valueTypes.bytes) {
    const length = decodeValue(buffer, byteOffset)
    const start = length.byteOffset
    const end = start + length.value

    if (type === valueTypes.numberString) {
      const value = Number(buffer.toString('utf8', start, end))
      return { byteOffset: end, value }
    }

    if (type === valueTypes.utf8) {
      const value = buffer.toString('utf8', start, end)
      return { byteOffset: end, value }
    }

    const value = buffer.slice(start, end)
    return { byteOffset: end, value }
  }

  if (type === valueTypes.list || type === valueTypes.descriptor) {
    const length = decodeValue(buffer, byteOffset)
    byteOffset = length.byteOffset

    const value = new Array(length.value)
    if (type === valueTypes.descriptor) {
      value[descriptorSymbol] = true
    }

    for (let index = 0; index < length.value; index++) {
      const item = decodeValue(buffer, byteOffset)
      byteOffset = item.byteOffset
      value[index] = item.value
    }

    return { byteOffset, value }
  }

  const hex = `0x${type.toString(16).toUpperCase()}`
  throw new TypeError(`Could not decode type ${hex}`)
}

function concatEncoded (deepArray) {
  const array = flattenDeep(deepArray)
  const buffers = new Array(array.length)
  let byteLength = 0
  for (let index = 0; index < array.length; index++) {
    if (typeof array[index] === 'number') {
      byteLength += 1
      const byte = Buffer.alloc(1)
      byte.writeUInt8(array[index])
      buffers[index] = byte
    } else {
      byteLength += array[index].byteLength
      buffers[index] = array[index]
    }
  }
  return Buffer.concat(buffers, byteLength)
}

function encode (rootRecord) {
  const buffers = []
  const pointers = []
  let byteOffset = 0

  const versionHeader = concatEncoded([encodeValue(VERSION)])
  buffers.push(versionHeader)
  byteOffset += versionHeader.byteLength

  const queue = [rootRecord]
  while (queue.length > 0) {
    if (pointers.length > 0) {
      pointers.shift().writeUInt32LE(byteOffset, 0)
    }

    const record = queue.shift()
    const recordHeader = concatEncoded([
      record.id,
      encodeValue(record.children.length)
    ])
    buffers.push(recordHeader)
    byteOffset += recordHeader.byteLength

    // Add pointers before encoding the state. This allows, if it ever becomes
    // necessary, for records to be extracted from a buffer without having to
    // parse the (variable length) state field.
    for (const child of record.children) {
      queue.push(child)

      const pointer = Buffer.alloc(4)
      pointers.push(pointer)
      buffers.push(pointer)
      byteOffset += 4
    }

    const state = concatEncoded([encodeValue(record.state)])
    buffers.push(state)
    byteOffset += state.byteLength
  }

  return Buffer.concat(buffers, byteOffset)
}
exports.encode = encode

function decodeRecord (buffer, byteOffset) {
  const id = buffer.readUInt8(byteOffset)
  byteOffset += 1

  const numPointers = decodeValue(buffer, byteOffset)
  byteOffset = numPointers.byteOffset

  const pointerAddresses = new Array(numPointers.value)
  for (let index = 0; index < numPointers.value; index++) {
    pointerAddresses[index] = buffer.readUInt32LE(byteOffset)
    byteOffset += 4
  }

  const state = decodeValue(buffer, byteOffset).value
  return {
    id,
    state,
    pointerAddresses
  }
}
exports.decodeRecord = decodeRecord

function decode (buffer) {
  const version = decodeValue(buffer, 0)
  if (version.value !== VERSION) {
    // TODO: Custom error class, better message, expose `version.value`
    throw new Error('Cannot decode buffer, it was encoded with a newer version')
  }

  return decodeRecord(buffer, version.byteOffset)
}
exports.decode = decode
